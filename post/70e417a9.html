<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>如何理解SO_REUSEADDR和SO_REUSEPORT？ | Lixiang's Blog</title><meta name="author" content="Lixiang"><meta name="copyright" content="Lixiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="注：（这篇文章原文是stack overflow的回答，觉得写的甚好，就转载保存下。原文连接） Welcome to the wonderful world of portability… or rather the lack of it. Before we start analyzing these two options in detail and take a deeper look ho">
<meta property="og:type" content="article">
<meta property="og:title" content="如何理解SO_REUSEADDR和SO_REUSEPORT？">
<meta property="og:url" content="https://lixiang365.github.io/post/70e417a9.html">
<meta property="og:site_name" content="Lixiang&#39;s Blog">
<meta property="og:description" content="注：（这篇文章原文是stack overflow的回答，觉得写的甚好，就转载保存下。原文连接） Welcome to the wonderful world of portability… or rather the lack of it. Before we start analyzing these two options in detail and take a deeper look ho">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-03-17T12:52:00.000Z">
<meta property="article:modified_time" content="2024-03-17T12:52:46.000Z">
<meta property="article:author" content="Lixiang">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lixiang365.github.io/post/70e417a9.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":1000,"position":"bottom","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Lixiang","link":"链接: ","source":"来源: Lixiang's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '如何理解SO_REUSEADDR和SO_REUSEPORT？',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-17 20:52:46'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Lixiang's Blog" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="Lixiang's Blog" type="application/rss+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Lixiang's Blog"><span class="site-name">Lixiang's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">如何理解SO_REUSEADDR和SO_REUSEPORT？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-17T12:52:00.000Z" title="发表于 2024-03-17 20:52:00">2024-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-17T12:52:46.000Z" title="更新于 2024-03-17 20:52:46">2024-03-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注：（这篇文章原文是stack overflow的回答，觉得写的甚好，就转载保存下。<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14388706/how-do-so-reuseaddr-and-so-reuseport-differ">原文连接</a>）</p>
<p>Welcome to the wonderful world of portability… or rather the lack of it. Before we start analyzing these two options in detail and take a deeper look how different operating systems handle them, it should be noted that the BSD socket implementation is the mother of all socket implementations. Basically all other systems copied the BSD socket implementation at some point in time (or at least its interfaces) and then started evolving it on their own. Of course the BSD socket implementation was evolved as well at the same time and thus systems that copied it later got features that were lacking in systems that copied it earlier. Understanding the BSD socket implementation is the key to understanding all other socket implementations, so you should read about it even if you don’t care to ever write code for a BSD system.<br>欢迎来到便携性的美妙世界……或者更确切地说是缺乏它。在我们开始详细分析这两个选项并更深入地了解不同的操作系统如何处理它们之前，应该注意的是，BSD 套接字实现是所有套接字实现之母。基本上，所有其他系统都在某个时间点（或至少是它的接口）复制了 BSD 套接字的实现，然后开始自己发展它。当然，BSD 套接字的实现也是同时发展起来的，因此后来复制它的系统获得了早期复制它的系统所缺乏的功能。了解 BSD 套接字实现是理解所有其他套接字实现的关键，因此即使您不想为 BSD 系统编写代码，也应该阅读它。</p>
<p>There are a couple of basics you should know before we look at these two options. A TCP&#x2F;UDP connection is identified by a tuple of five values:<br>在我们研究这两个选项之前，您应该了解一些基础知识。TCP&#x2F;UDP 连接由五个值的元组标识：</p>
<p><code>&#123;&lt;protocol&gt;, &lt;src addr&gt;, &lt;src port&gt;, &lt;dest addr&gt;, &lt;dest port&gt;&#125;</code></p>
<p>Any unique combination of these values identifies a connection. As a result, no two connections can have the same five values, otherwise the system would not be able to distinguish these connections any longer.<br>这些值的任何唯一组合都标识连接。因此，任何两个连接都不能具有相同的五个值，否则系统将无法再区分这些连接。</p>
<p>The protocol of a socket is set when a socket is created with the socket() function. The source address and port are set with the bind() function. The destination address and port are set with the connect() function. Since UDP is a connectionless protocol, UDP sockets can be used without connecting them. Yet it is allowed to connect them and in some cases very advantageous for your code and general application design. In connectionless mode, UDP sockets that were not explicitly bound when data is sent over them for the first time are usually automatically bound by the system, as an unbound UDP socket cannot receive any (reply) data. Same is true for an unbound TCP socket, it is automatically bound before it will be connected.<br>套接字的协议是在使用 socket() 函数创建套接字时设置的。源地址和端口通过 bind() 函数设置。目标地址和端口通过该 connect() 功能设置。由于 UDP 是一种无连接协议，因此可以在不连接 UDP 套接字的情况下使用 UDP 套接字。然而，它被允许连接它们，在某些情况下对你的代码和一般应用程序设计非常有利。在无连接模式下，首次通过UDP套接字发送数据时未显式绑定的UDP套接字通常由系统自动绑定，因为未绑定的UDP套接字无法接收任何（应答）数据。未绑定的 TCP 套接字也是如此，它在连接之前会自动绑定。</p>
<p>If you explicitly bind a socket, it is possible to bind it to port 0, which means “any port”. Since a socket cannot really be bound to all existing ports, the system will have to choose a specific port itself in that case (usually from a predefined, OS specific range of source ports). A similar wildcard exists for the source address, which can be “any address” (0.0.0.0 in case of IPv4 and :: in case of IPv6). Unlike in case of ports, a socket can really be bound to “any address” which means “all source IP addresses of all local interfaces”. If the socket is connected later on, the system has to choose a specific source IP address, since a socket cannot be connected and at the same time be bound to any local IP address. Depending on the destination address and the content of the routing table, the system will pick an appropriate source address and replace the “any” binding with a binding to the chosen source IP address.<br>如果显式绑定套接字，则可以将其绑定到 port 0 ，这意味着“任何端口”。由于套接字不能真正绑定到所有现有端口，因此在这种情况下，系统必须选择特定端口本身（通常来自预定义的、特定于操作系统的源端口范围）。源地址也存在类似的通配符，可以是“任何地址”（ 0.0.0.0 在 IPv4 和 :: IPv6 的情况下）。与端口不同，套接字实际上可以绑定到“任何地址”，这意味着“所有本地接口的所有源 IP 地址”。如果稍后连接套接字，系统必须选择特定的源 IP 地址，因为套接字无法连接并同时绑定到任何本地 IP 地址。根据目标地址和路由表的内容，系统将选择适当的源地址，并将“any”绑定替换为与所选源 IP 地址的绑定。</p>
<p>By default, no two sockets can be bound to the same combination of source address and source port. As long as the source port is different, the source address is actually irrelevant. Binding socketA to ipA:portA and socketB to ipB:portB is always possible if ipA !&#x3D; ipB holds true, even when portA &#x3D;&#x3D; portB. E.g. socketA belongs to a FTP server program and is bound to 192.168.0.1:21 and socketB belongs to another FTP server program and is bound to 10.0.0.1:21, both bindings will succeed. Keep in mind, though, that a socket may be locally bound to “any address”. If a socket is bound to 0.0.0.0:21, it is bound to all existing local addresses at the same time and in that case no other socket can be bound to port 21, regardless which specific IP address it tries to bind to, as 0.0.0.0 conflicts with all existing local IP addresses.<br>默认情况下，两个套接字不能绑定到源地址和源端口的相同组合。只要源端口不同，源地址其实是无关紧要的。如果成立 true，则始终可以绑定 socketA 到 ipA:portA 和 socketB to ipB:portB ，即使 portA &#x3D;&#x3D; portB . ipA !&#x3D; ipB 例如， socketA 属于一个FTP服务器程序，并且绑定到 192.168.0.1:21 另一个FTP服务器程序并 socketB 属于另一个FTP服务器程序，并且绑定到 10.0.0.1:21 ，两个绑定都会成功。但请记住，套接字可能在本地绑定到“任何地址”。如果套接字绑定到 0.0.0.0:21 ，则它同时绑定到所有现有的本地地址，在这种情况下，其他套接字都不能绑定到 端口 21 ，无论它尝试绑定到哪个特定的 IP 地址，因为 0.0.0.0 与所有现有的本地 IP 地址冲突。</p>
<p>Anything said so far is pretty much equal for all major operating system. Things start to get OS specific when address reuse comes into play. We start with BSD, since as I said above, it is the mother of all socket implementations.<br>到目前为止，对于所有主要操作系统来说，所说的任何事情几乎都是平等的。当地址重用发挥作用时，事情开始变得特定于操作系统。我们从 BSD 开始，因为正如我上面所说，它是所有套接字实现之母。</p>
<h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><h3 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h3><p>If SO_REUSEADDR is enabled on a socket prior to binding it, the socket can be successfully bound unless there is a conflict with another socket bound to exactly the same combination of source address and port. Now you may wonder how is that any different than before? The keyword is “exactly”. SO_REUSEADDR mainly changes the way how wildcard addresses (“any IP address”) are treated when searching for conflicts.<br>如果 SO_REUSEADDR 在绑定套接字之前在套接字上启用了套接字，则可以成功绑定套接字，除非与绑定到完全相同的源地址和端口组合的另一个套接字发生冲突。现在你可能想知道这和以前有什么不同？关键词是“确切地”。 SO_REUSEADDR 主要更改了搜索冲突时处理通配符地址（“任何 IP 地址”）的方式。</p>
<p>Without SO_REUSEADDR, binding socketA to 0.0.0.0:21 and then binding socketB to 192.168.0.1:21 will fail (with error EADDRINUSE), since 0.0.0.0 means “any local IP address”, thus all local IP addresses are considered in use by this socket and this includes 192.168.0.1, too. With SO_REUSEADDR it will succeed, since 0.0.0.0 and 192.168.0.1 are not exactly the same address, one is a wildcard for all local addresses and the other one is a very specific local address. Note that the statement above is true regardless in which order socketA and socketB are bound; without SO_REUSEADDR it will always fail, with SO_REUSEADDR it will always succeed.<br>如果没有 SO_REUSEADDR ，绑定 socketA 到 0.0.0.0:21 然后绑定 socketB 到 192.168.0.1:21 将失败（有错误 EADDRINUSE ），因为 0.0.0.0 表示“任何本地 IP 地址”，因此所有本地 IP 地址都被视为由此套接字使用，这也包括 192.168.0.1 。有了 SO_REUSEADDR 它，它就会成功，因为 0.0.0.0 和 192.168.0.1 不是完全相同的地址，一个是所有本地地址的通配符，另一个是非常具体的本地地址。请注意，无论以何种顺序 socketA 和 socketB 绑定，上述陈述都是正确的;没有 SO_REUSEADDR 它，它将永远失败，它 SO_REUSEADDR 将永远成功。</p>
<p>To give you a better overview, let’s make a table here and list all possible combinations:<br>为了给您一个更好的概述，让我们在这里制作一个表格并列出所有可能的组合：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SO_REUSEADDR       socketA        socketB       Result</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">  ON/OFF       192.168.0.1:21   192.168.0.1:21    Error (EADDRINUSE)</span><br><span class="line">  ON/OFF       192.168.0.1:21      10.0.0.1:21    OK</span><br><span class="line">  ON/OFF          10.0.0.1:21   192.168.0.1:21    OK</span><br><span class="line">   OFF             0.0.0.0:21   192.168.1.0:21    Error (EADDRINUSE)</span><br><span class="line">   OFF         192.168.1.0:21       0.0.0.0:21    Error (EADDRINUSE)</span><br><span class="line">   ON              0.0.0.0:21   192.168.1.0:21    OK</span><br><span class="line">   ON          192.168.1.0:21       0.0.0.0:21    OK</span><br><span class="line">  ON/OFF           0.0.0.0:21       0.0.0.0:21    Error (EADDRINUSE)</span><br></pre></td></tr></table></figure>

<p>The table above assumes that socketA has already been successfully bound to the address given for socketA, then socketB is created, either gets SO_REUSEADDR set or not, and finally is bound to the address given for socketB. Result is the result of the bind operation for socketB. If the first column says ON&#x2F;OFF, the value of SO_REUSEADDR is irrelevant to the result.<br>上表假设 socketA 已经成功绑定到 的 socketA 地址，然后 socketB 创建，设置或不设置 SO_REUSEADDR ，最后绑定到 给定 socketB 的地址。 Result 是 的绑定操作的结果 socketB 。如果第一列说 ON&#x2F;OFF ，则 的 SO_REUSEADDR 值与结果无关。</p>
<p>Okay, SO_REUSEADDR has an effect on wildcard addresses, good to know. Yet that isn’t its only effect it has. There is another well known effect which is also the reason why most people use SO_REUSEADDR in server programs in the first place. For the other important use of this option we have to take a deeper look on how the TCP protocol works.<br>好的， SO_REUSEADDR 对通配符地址有影响，很高兴知道。然而，这并不是它唯一的影响。还有另一个众所周知的效果，这也是大多数人首先在服务器程序中使用 SO_REUSEADDR 的原因。对于此选项的另一个重要用途，我们必须更深入地了解 TCP 协议的工作原理。</p>
<p>If a TCP socket is being closed, normally a 3-way handshake is performed; the sequence is called FIN-ACK. The problem here is, that the last ACK of that sequence may have arrived on the other side or it may not have arrived and only if it has, the other side also considers the socket as being fully closed. To prevent re-using an address+port combination, that may still be considered open by some remote peer, the system will not immediately consider a socket as dead after sending the last ACK but instead put the socket into a state commonly referred to as TIME_WAIT. It can be in that state for minutes (system dependent setting). On most systems you can get around that state by enabling lingering and setting a linger time of zero1 but there is no guarantee that this is always possible, that the system will always honor this request, and even if the system honors it, this causes the socket to be closed by a reset (RST), which is not always a great idea. To learn more about linger time, have a look at my answer about this topic.<br>如果 TCP 套接字正在关闭，通常会执行 3 次握手;该序列称为 FIN-ACK 。这里的问题是，该序列的最后一个 ACK 可能已经到达另一端，也可能没有到达，只有当它到达时，另一端也认为套接字是完全关闭的。为了防止重复使用地址+端口组合，该组合可能仍被某些远程对等方视为打开，系统不会在发送最后一个 ACK 套接字后立即将套接字视为死套接字，而是将套接字置于通常称为 TIME_WAIT 的状态。它可以处于该状态几分钟（取决于系统设置）。在大多数系统上，您可以通过启用延迟并将延迟时间设置为 zero1 来绕过该状态，但不能保证这始终是可能的，系统将始终遵守此请求，即使系统遵守它，这也会导致套接字通过重置 （ RST ） 关闭，这并不总是一个好主意。要了解有关逗留时间的更多信息，请查看我对此主题的回答。</p>
<p>The question is, how does the system treat a socket in state TIME_WAIT? If SO_REUSEADDR is not set, a socket in state TIME_WAIT is considered to still be bound to the source address and port and any attempt to bind a new socket to the same address and port will fail until the socket has really been closed. So don’t expect that you can rebind the source address of a socket immediately after closing it. In most cases this will fail. However, if SO_REUSEADDR is set for the socket you are trying to bind, another socket bound to the same address and port in state TIME_WAIT is simply ignored, after all its already “half dead”, and your socket can bind to exactly the same address without any problem. In that case it plays no role that the other socket may have exactly the same address and port. Note that binding a socket to exactly the same address and port as a dying socket in TIME_WAIT state can have unexpected, and usually undesired, side effects in case the other socket is still “at work”, but that is beyond the scope of this answer and fortunately those side effects are rather rare in practice.<br>问题是，系统如何处理处于状态 TIME_WAIT 的套接字？如果 SO_REUSEADDR 未设置，则认为处于状态 TIME_WAIT 的套接字仍绑定到源地址和端口，并且任何将新套接字绑定到同一地址和端口的尝试都将失败，直到套接字真正关闭。所以不要指望在关闭套接字后立即重新绑定套接字的源地址。在大多数情况下，这将失败。但是，如果 SO_REUSEADDR 为您尝试绑定的套接字设置了套接字，则绑定到相同地址和端口状态 TIME_WAIT 的另一个套接字将被忽略，毕竟它已经“半死不活”了，并且您的套接字可以绑定到完全相同的地址而不会出现任何问题。在这种情况下，另一个套接字可能具有完全相同的地址和端口，这不起作用。请注意，如果另一个套接字仍在“工作”，将一个套接字绑定到与 TIME_WAIT 处于状态的垂死套接字完全相同的地址和端口可能会产生意想不到的副作用，而且通常是不希望的副作用，但这超出了这个答案的范围，幸运的是，这些副作用在实践中相当罕见。</p>
<p>There is one final thing you should know about SO_REUSEADDR. Everything written above will work as long as the socket you want to bind to has address reuse enabled. It is not necessary that the other socket, the one which is already bound or is in a TIME_WAIT state, also had this flag set when it was bound. The code that decides if the bind will succeed or fail only inspects the SO_REUSEADDR flag of the socket fed into the bind() call, for all other sockets inspected, this flag is not even looked at.<br>还有最后一件事你应该知道 SO_REUSEADDR 。只要您要绑定到的套接字启用了地址重用，上面写的所有内容都会起作用。另一个套接字（已绑定或处于某种 TIME_WAIT 状态的套接字）在绑定时也不必设置此标志。决定绑定是成功还是失败的代码仅检查馈入调用的 bind() 套接字 SO_REUSEADDR 的标志，对于检查的所有其他套接字，甚至不查看此标志。</p>
<h3 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a>SO_REUSEPORT</h3><p>SO_REUSEPORT is what most people would expect SO_REUSEADDR to be. Basically, SO_REUSEPORT allows you to bind an arbitrary number of sockets to exactly the same source address and port as long as all prior bound sockets also had SO_REUSEPORT set before they were bound. If the first socket that is bound to an address and port does not have SO_REUSEPORT set, no other socket can be bound to exactly the same address and port, regardless if this other socket has SO_REUSEPORT set or not, until the first socket releases its binding again. Unlike in case of SO_REUSEADDR the code handling SO_REUSEPORT will not only verify that the currently bound socket has SO_REUSEPORT set but it will also verify that the socket with a conflicting address and port had SO_REUSEPORT set when it was bound.<br>SO_REUSEPORT 是大多数人所期望 SO_REUSEADDR 的。基本上， SO_REUSEPORT 允许您将任意数量的套接字绑定到完全相同的源地址和端口，只要所有先前绑定的套接字在绑定之前也已 SO_REUSEPORT 设置。如果绑定到地址和端口的第一个套接字未 SO_REUSEPORT 设置，则在第一个套接字再次释放其绑定之前，不能将其他套接字绑定到完全相同的地址和端口，无论该其他套接字是否已 SO_REUSEPORT 设置。与代码不同的是 SO_REUSEADDR ，处理 SO_REUSEPORT 不仅会验证当前绑定的套接字是否已 SO_REUSEPORT 设置，还会验证具有冲突地址和端口的套接字在绑定时是否已 SO_REUSEPORT 设置。</p>
<p>SO_REUSEPORT does not imply SO_REUSEADDR. This means if a socket did not have SO_REUSEPORT set when it was bound and another socket has SO_REUSEPORT set when it is bound to exactly the same address and port, the bind fails, which is expected, but it also fails if the other socket is already dying and is in TIME_WAIT state. To be able to bind a socket to the same addresses and port as another socket in TIME_WAIT state requires either SO_REUSEADDR to be set on that socket or SO_REUSEPORT must have been set on both sockets prior to binding them. Of course it is allowed to set both, SO_REUSEPORT and SO_REUSEADDR, on a socket.<br>SO_REUSEPORT 并不意味着 SO_REUSEADDR .这意味着，如果一个套接字在绑定时没有 SO_REUSEPORT 设置，而另一个套接字在绑定到完全相同的地址和端口时设置 SO_REUSEPORT 了，则绑定会失败，这是意料之中的，但如果另一个套接字已经死亡并处于 TIME_WAIT 状态，则绑定也会失败。为了能够将套接字绑定到与 TIME_WAIT 处于状态的另一个套接字相同的地址和端口，需要 SO_REUSEADDR 在该套接字上设置，或者 SO_REUSEPORT 必须在绑定两个套接字之前在两个套接字上设置它们。当然， SO_REUSEPORT 允许在套接字上同时设置 和 SO_REUSEADDR 。</p>
<p>There is not much more to say about SO_REUSEPORT other than that it was added later than SO_REUSEADDR, that’s why you will not find it in many socket implementations of other systems, which “forked” the BSD code before this option was added, and that there was no way to bind two sockets to exactly the same socket address in BSD prior to this option.<br>除了添加它晚于 SO_REUSEADDR 之外，没有什么可说 SO_REUSEPORT 的，这就是为什么你不会在其他系统的许多套接字实现中找到它的原因，这些系统在添加此选项之前“分叉”了 BSD 代码，并且没有办法将两个套接字绑定到此选项之前 BSD 中完全相同的套接字地址。</p>
<h3 id="Connect-Returning-EADDRINUSE"><a href="#Connect-Returning-EADDRINUSE" class="headerlink" title="Connect() Returning EADDRINUSE?"></a>Connect() Returning EADDRINUSE?</h3><p>connect（） 返回 EADDRINUSE？<br>Most people know that bind() may fail with the error EADDRINUSE, however, when you start playing around with address reuse, you may run into the strange situation that connect() fails with that error as well. How can this be? How can a remote address, after all that’s what connect adds to a socket, be already in use? Connecting multiple sockets to exactly the same remote address has never been a problem before, so what’s going wrong here?<br>大多数人都知道 bind() 可能会因错误 EADDRINUSE 而失败，但是，当您开始尝试地址重用时，您可能会遇到该错误 connect() 失败的奇怪情况。这怎么可能？远程地址，毕竟这是连接添加到套接字的内容，怎么可能已经在使用中？将多个套接字连接到完全相同的远程地址以前从未成为问题，那么这里出了什么问题呢？</p>
<p>As I said on the very top of my reply, a connection is defined by a tuple of five values, remember? And I also said, that these five values must be unique otherwise the system cannot distinguish two connections any longer, right? Well, with address reuse, you can bind two sockets of the same protocol to the same source address and port. That means three of those five values are already the same for these two sockets. If you now try to connect both of these sockets also to the same destination address and port, you would create two connected sockets, whose tuples are absolutely identical. This cannot work, at least not for TCP connections (UDP connections are no real connections anyway). If data arrived for either one of the two connections, the system could not tell which connection the data belongs to. At least the destination address or destination port must be different for either connection, so that the system has no problem to identify to which connection incoming data belongs to.<br>正如我在回复的最上面所说，连接是由五个值组成的元组定义的，还记得吗？我还说，这五个值必须是唯一的，否则系统就无法再区分两个连接了，对吧？好吧，通过地址重用，您可以将同一协议的两个套接字绑定到相同的源地址和端口。这意味着这两个套接字的这五个值中的三个已经相同。如果现在尝试将这两个套接字也连接到相同的目标地址和端口，则将创建两个连接的套接字，其元组完全相同。这行不通，至少对于TCP连接不起作用（UDP连接无论如何都不是真正的连接）。如果数据到达两个连接中的任何一个，系统无法判断数据属于哪个连接。对于任一连接，至少目标地址或目标端口必须不同，以便系统在识别传入数据属于哪个连接时没有问题。</p>
<p>So if you bind two sockets of the same protocol to the same source address and port and try to connect them both to the same destination address and port, connect() will actually fail with the error EADDRINUSE for the second socket you try to connect, which means that a socket with an identical tuple of five values is already connected.<br>因此，如果将相同协议的两个套接字绑定到相同的源地址和端口，并尝试将它们都连接到相同的目标地址和端口， connect() 则实际上会失败，并出现您尝试连接的第二个套接字的错误 EADDRINUSE ，这意味着具有相同元组的五个值的套接字已经连接。</p>
<h3 id="Multicast-Addresses-组播地址"><a href="#Multicast-Addresses-组播地址" class="headerlink" title="Multicast Addresses 组播地址"></a>Multicast Addresses 组播地址</h3><p>Most people ignore the fact that multicast addresses exist, but they do exist. While unicast addresses are used for one-to-one communication, multicast addresses are used for one-to-many communication. Most people got aware of multicast addresses when they learned about IPv6 but multicast addresses also existed in IPv4, even though this feature was never widely used on the public Internet.<br>大多数人忽略了多播地址存在的事实，但它们确实存在。单播地址用于一对一通信，而组播地址用于一对多通信。大多数人在了解 IPv6 时就知道组播地址，但组播地址也存在于 IPv4 中，尽管此功能从未在公共 Internet 上广泛使用。</p>
<p>The meaning of SO_REUSEADDR changes for multicast addresses as it allows multiple sockets to be bound to exactly the same combination of source multicast address and port. In other words, for multicast addresses SO_REUSEADDR behaves exactly as SO_REUSEPORT for unicast addresses. Actually, the code treats SO_REUSEADDR and SO_REUSEPORT identically for multicast addresses, that means you could say that SO_REUSEADDR implies SO_REUSEPORT for all multicast addresses and the other way round.<br>SO_REUSEADDR 更改组播地址的含义，因为它允许将多个套接字绑定到完全相同的源组播地址和端口组合。换言之，对于组播地址 SO_REUSEADDR 的行为与 SO_REUSEPORT 单播地址的行为完全相同。实际上，代码对组播地址的处理 SO_REUSEADDR 方式 SO_REUSEPORT 相同，这意味着您可以说这意味着 SO_REUSEADDR SO_REUSEPORT 所有组播地址，反之亦然。</p>
<h2 id="FreeBSD-OpenBSD-NetBSD"><a href="#FreeBSD-OpenBSD-NetBSD" class="headerlink" title="FreeBSD&#x2F;OpenBSD&#x2F;NetBSD"></a>FreeBSD&#x2F;OpenBSD&#x2F;NetBSD</h2><p>All these are rather late forks of the original BSD code, that’s why they all three offer the same options as BSD and they also behave the same way as in BSD.<br>所有这些都是原始 BSD 代码的后期分支，这就是为什么它们都提供与 BSD 相同的选项，并且它们的行为方式也与 BSD 相同。</p>
<h3 id="macOS-MacOS-X"><a href="#macOS-MacOS-X" class="headerlink" title="macOS (MacOS X)"></a>macOS (MacOS X)</h3><p>macOS （MacOS X）<br>At its core, macOS is simply a BSD-style UNIX named “Darwin”, based on a rather late fork of the BSD code (BSD 4.3), which was then later on even re-synchronized with the (at that time current) FreeBSD 5 code base for the Mac OS 10.3 release, so that Apple could gain full POSIX compliance (macOS is POSIX certified). Despite having a microkernel at its core (“Mach”), the rest of the kernel (“XNU”) is basically just a BSD kernel, and that’s why macOS offers the same options as BSD and they also behave the same way as in BSD.<br>从本质上讲，macOS 只是一个名为“Darwin”的 BSD 风格的 UNIX，它基于 BSD 代码（BSD 4.3）的一个相当晚的分支，后来甚至与 Mac OS 10.3 版本的 FreeBSD 5 代码库重新同步，以便 Apple 可以获得完全的 POSIX 合规性（macOS 已获得 POSIX 认证）。尽管其核心有一个微内核（“Mach”），但内核的其余部分（“XNU”）基本上只是一个 BSD 内核，这就是为什么 macOS 提供与 BSD 相同的选项，并且它们的行为方式也与 BSD 相同。</p>
<h3 id="iOS-watchOS-tvOS"><a href="#iOS-watchOS-tvOS" class="headerlink" title="iOS &#x2F; watchOS &#x2F; tvOS"></a>iOS &#x2F; watchOS &#x2F; tvOS</h3><p>iOS&#x2F;watchOS &#x2F; tvOS<br>iOS is just a macOS fork with a slightly modified and trimmed kernel, somewhat stripped down user space toolset and a slightly different default framework set. watchOS and tvOS are iOS forks, that are stripped down even further (especially watchOS). To my best knowledge they all behave exactly as macOS does.<br>iOS 只是一个 macOS 分支，具有略微修改和修剪的内核、略微精简的用户空间工具集和略有不同的默认框架集。watchOS 和 tvOS 是 iOS 的分支，它们被进一步精简（尤其是 watchOS）。据我所知，它们的行为都与 macOS 完全相同。</p>
<h2 id="Linux-Linux操作系统"><a href="#Linux-Linux操作系统" class="headerlink" title="Linux Linux操作系统"></a>Linux Linux操作系统</h2><h3 id="Linux-3-9"><a href="#Linux-3-9" class="headerlink" title="Linux &lt; 3.9"></a>Linux &lt; 3.9</h3><p>Prior to Linux 3.9, only the option SO_REUSEADDR existed. This option behaves generally the same as in BSD with two important exceptions:<br>在 Linux 3.9 之前，只有该选项 SO_REUSEADDR 存在。此选项的行为与 BSD 中的行为大致相同，但有两个重要的例外：</p>
<p>As long as a listening (server) TCP socket is bound to a specific port, the SO_REUSEADDR option is entirely ignored for all sockets targeting that port. Binding a second socket to the same port is only possible if it was also possible in BSD without having SO_REUSEADDR set. E.g. you cannot bind to a wildcard address and then to a more specific one or the other way round, both is possible in BSD if you set SO_REUSEADDR. What you can do is you can bind to the same port and two different non-wildcard addresses, as that’s always allowed. In this aspect Linux is more restrictive than BSD.<br>只要侦听（服务器）TCP 套接字绑定到特定端口，则对于面向该端口的所有套接字，该 SO_REUSEADDR 选项将被完全忽略。只有在 BSD 中也可以将第二个套接字绑定到同一端口而无需 SO_REUSEADDR 设置时才有可能。例如，你不能绑定到一个通配符地址，然后绑定到一个更具体的地址，或者相反，如果你设置 SO_REUSEADDR 了 .您可以做的是绑定到相同的端口和两个不同的非通配符地址，因为这始终是允许的。在这方面，Linux 比 BSD 更具限制性。</p>
<p>The second exception is that for client sockets, this option behaves exactly like SO_REUSEPORT in BSD, as long as both had this flag set before they were bound. The reason for allowing that was simply that it is important to be able to bind multiple sockets to exactly to the same UDP socket address for various protocols and as there used to be no SO_REUSEPORT prior to 3.9, the behavior of SO_REUSEADDR was altered accordingly to fill that gap. In that aspect Linux is less restrictive than BSD.<br>第二个例外是，对于客户端套接字，此选项的行为与 BSD 中的行为完全相同 SO_REUSEPORT ，只要两者在绑定之前都设置了此标志即可。允许这样做的原因很简单，能够将多个套接字绑定到各种协议的同一 UDP 套接字地址非常重要，并且由于 3.9 之前没有 SO_REUSEPORT ，因此相应地更改了 的行为 SO_REUSEADDR 以填补这一空白。在这方面，Linux 的限制比 BSD 少。</p>
<h3 id="Linux-3-9-1"><a href="#Linux-3-9-1" class="headerlink" title="Linux &gt;&#x3D; 3.9"></a>Linux &gt;&#x3D; 3.9</h3><p>Linux 3.9 added the option SO_REUSEPORT to Linux as well. This option behaves exactly like the option in BSD and allows binding to exactly the same address and port number as long as all sockets have this option set prior to binding them.<br>Linux 3.9 也为 Linux 添加了该选项 SO_REUSEPORT 。此选项的行为与 BSD 中的选项完全相同，并且允许绑定到完全相同的地址和端口号，只要所有套接字在绑定之前都设置了此选项。</p>
<p>Yet, there are still two differences to SO_REUSEPORT on other systems:<br>然而，与其他 SO_REUSEPORT 系统相比，仍然有两个区别：</p>
<p>To prevent “port hijacking”, there is one special limitation: All sockets that want to share the same address and port combination must belong to processes that share the same effective user ID! So one user cannot “steal” ports of another user. This is some special magic to somewhat compensate for the missing SO_EXCLBIND&#x2F;SO_EXCLUSIVEADDRUSE flags.<br>为了防止“端口劫持”，有一个特殊的限制：所有想要共享相同地址和端口组合的套接字必须属于共享相同有效用户 ID 的进程！因此，一个用户不能“窃取”另一个用户的端口。这是一些特殊的魔法，可以在一定程度上弥补丢失 SO_EXCLBIND 的&#x2F; SO_EXCLUSIVEADDRUSE 标志。</p>
<p>Additionally the kernel performs some “special magic” for SO_REUSEPORT sockets that isn’t found in other operating systems: For UDP sockets, it tries to distribute datagrams evenly, for TCP listening sockets, it tries to distribute incoming connect requests (those accepted by calling accept()) evenly across all the sockets that share the same address and port combination. Thus an application can easily open the same port in multiple child processes and then use SO_REUSEPORT to get a very inexpensive load balancing.<br>此外，内核还对 SO_REUSEPORT 套接字执行了一些在其他操作系统中没有的“特殊魔术”：对于 UDP 套接字，它尝试均匀地分配数据报，对于 TCP 侦听套接字，它尝试在共享相同地址和端口组合的所有套接字之间均匀地分配传入的连接请求（通过调用 accept() 接受的请求）。因此，应用程序可以很容易地在多个子进程中打开同一个端口，然后用于 SO_REUSEPORT 获得非常便宜的负载平衡。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>Even though the whole Android system is somewhat different from most Linux distributions, at its core works a slightly modified Linux kernel, thus everything that applies to Linux should apply to Android as well.<br>尽管整个 Android 系统与大多数 Linux 发行版有些不同，但其核心工作是略微修改的 Linux 内核，因此适用于 Linux 的所有内容也应该适用于 Android。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>Windows only knows the SO_REUSEADDR option, there is no SO_REUSEPORT. Setting SO_REUSEADDR on a socket in Windows behaves like setting SO_REUSEPORT and SO_REUSEADDR on a socket in BSD, with one exception:<br>Windows只知道 SO_REUSEADDR 这个选项，没有 SO_REUSEPORT .在 Windows 中的套接字上进行设置 SO_REUSEADDR 的行为类似于 BSD 中的设置 SO_REUSEPORT 和 SO_REUSEADDR 套接字，但有一个例外：</p>
<p>Prior to Windows 2003, a socket with SO_REUSEADDR could always been bound to exactly the same source address and port as an already bound socket, even if the other socket did not have this option set when it was bound. This behavior allowed an application “to steal” the connected port of another application. Needless to say that this has major security implications!<br>在 Windows 2003 之前，一个 SO_REUSEADDR 套接字始终可以绑定到与已绑定套接字完全相同的源地址和端口，即使另一个套接字在绑定时没有设置此选项。此行为允许应用程序“窃取”另一个应用程序的连接端口。毋庸置疑，这具有重大的安全隐患！</p>
<p>Microsoft realized that and added another important socket option: SO_EXCLUSIVEADDRUSE. Setting SO_EXCLUSIVEADDRUSE on a socket makes sure that if the binding succeeds, the combination of source address and port is owned exclusively by this socket and no other socket can bind to them, not even if it has SO_REUSEADDR set.<br>Microsoft意识到了这一点，并添加了另一个重要的套接字选项： SO_EXCLUSIVEADDRUSE .在套接字上设置 SO_EXCLUSIVEADDRUSE 可确保如果绑定成功，源地址和端口的组合仅由此套接字拥有，并且没有其他套接字可以绑定到它们，即使它已经 SO_REUSEADDR 设置了。</p>
<p>This default behavior was changed first in Windows 2003, Microsoft calls that “Enhanced Socket Security” (funny name for a behavior that is default on all other major operating systems). For more details just visit this page. There are three tables: The first one shows the classic behavior (still in use when using compatibility modes!), the second one shows the behavior of Windows 2003 and up when the bind() calls are made by the same user, and the third one when the bind() calls are made by different users.<br>此默认行为首先在 Windows 2003 中更改，Microsoft 将其称为“增强套接字安全性”（在所有其他主要操作系统上默认的行为的有趣名称）。有关更多详细信息，请访问此页面。有三个表：第一个表显示经典行为（使用兼容模式时仍在使用！），第二个表显示 Windows 2003 及更高版本由同一用户进行 bind() 调用时的行为，第三个表显示不同用户进行 bind() 调用时的行为。</p>
<h2 id="Solaris"><a href="#Solaris" class="headerlink" title="Solaris"></a>Solaris</h2><p>Solaris is the successor of SunOS. SunOS was originally based on a fork of BSD, SunOS 5 and later was based on a fork of SVR4, however SVR4 is a merge of BSD, System V, and Xenix, so up to some degree Solaris is also a BSD fork, and a rather early one. As a result Solaris only knows SO_REUSEADDR, there is no SO_REUSEPORT. The SO_REUSEADDR behaves pretty much the same as it does in BSD. As far as I know there is no way to get the same behavior as SO_REUSEPORT in Solaris, that means it is not possible to bind two sockets to exactly the same address and port.<br>Solaris 是 SunOS 的继任者。SunOS 最初是基于 BSD 的一个分支，SunOS 5 和后来的 SVR4 是基于 SVR4 的一个分支，但 SVR4 是 BSD、System V 和 Xenix 的合并，所以在某种程度上 Solaris 也是一个 BSD 分支，而且是一个相当早期的分支。结果Solaris只知道 SO_REUSEADDR ，没有 SO_REUSEPORT 。其 SO_REUSEADDR 行为与在 BSD 中的行为几乎相同。据我所知，没有办法获得与Solaris相同的行为 SO_REUSEPORT ，这意味着不可能将两个套接字绑定到完全相同的地址和端口。</p>
<p>Similar to Windows, Solaris has an option to give a socket an exclusive binding. This option is named SO_EXCLBIND. If this option is set on a socket prior to binding it, setting SO_REUSEADDR on another socket has no effect if the two sockets are tested for an address conflict. E.g. if socketA is bound to a wildcard address and socketB has SO_REUSEADDR enabled and is bound to a non-wildcard address and the same port as socketA, this bind will normally succeed, unless socketA had SO_EXCLBIND enabled, in which case it will fail regardless the SO_REUSEADDR flag of socketB.<br>与 Windows 类似，Solaris 可以选择为套接字提供独占绑定。此选项名为 SO_EXCLBIND 。如果在绑定套接字之前在套接字上设置了此选项，则在测试两个套接字是否存在地址冲突时，在另一个套接字上设置 SO_REUSEADDR 该选项将不起作用。例如，如果 socketA 绑定到通配符地址并 socketB 已 SO_REUSEADDR 启用并绑定到非通配符地址和与 socketA 相同的端口，则此绑定通常会成功，除非已 SO_EXCLBIND 启用，在这种情况下 socketA ，无论 . SO_REUSEADDR socketB</p>
<h2 id="Other-Systems-其他系统"><a href="#Other-Systems-其他系统" class="headerlink" title="Other Systems 其他系统"></a>Other Systems 其他系统</h2><p>In case your system is not listed above, I wrote a little test program that you can use to find out how your system handles these two options. Also if you think my results are wrong, please first run that program before posting any comments and possibly making false claims.<br>如果你的系统没有在上面列出，我写了一个小测试程序，你可以用它来了解你的系统如何处理这两个选项。另外，如果您认为我的结果是错误的，请先运行该程序，然后再发表任何评论并可能做出虚假声明。</p>
<p>All that the code requires to build is a bit POSIX API (for the network parts) and a C99 compiler (actually most non-C99 compiler will work as well as long as they offer inttypes.h and stdbool.h; e.g. gcc supported both long before offering full C99 support).<br>构建代码所需的只是一个 POSIX API（用于网络部分）和一个 C99 编译器（实际上，大多数非 C99 编译器只要它们提供 inttypes.h 和 stdbool.h 就可以工作;例如， gcc 在提供完整的 C99 支持之前很久就支持两者）。</p>
<p>All that the program needs to run is that at least one interface in your system (other than the local interface) has an IP address assigned and that a default route is set which uses that interface. The program will gather that IP address and use it as the second “specific address”.<br>程序运行所需的只是系统中至少有一个接口（本地接口除外）分配了一个 IP 地址，并且设置了使用该接口的默认路由。该程序将收集该 IP 地址并将其用作第二个“特定地址”。</p>
<p>It tests all possible combinations you can think of:<br>它测试了您能想到的所有可能的组合：</p>
<p>TCP and UDP protocol<br>TCP 和 UDP 协议<br>Normal sockets, listen (server) sockets, multicast sockets<br>普通套接字、侦听（服务器）套接字、组播套接字<br>SO_REUSEADDR set on socket1, socket2, or both sockets<br>SO_REUSEADDR 在 socket1、socket2 或两个套接字上设置<br>SO_REUSEPORT set on socket1, socket2, or both sockets<br>SO_REUSEPORT 在 socket1、socket2 或两个套接字上设置<br>All address combinations you can make out of 0.0.0.0 (wildcard), 127.0.0.1 (specific address), and the second specific address found at your primary interface (for multicast it’s just 224.1.2.3 in all tests)<br>您可以从 0.0.0.0 （通配符）、 127.0.0.1 （特定地址）和在主接口找到的第二个特定地址组合（对于多播，它只是 224.1.2.3 在所有测试中）<br>and prints the results in a nice table. It will also work on systems that don’t know SO_REUSEPORT, in which case this option is simply not tested.<br>并将结果打印在一个漂亮的表格中。它也将在不知道 SO_REUSEPORT 的系统上运行，在这种情况下，此选项根本没有经过测试。</p>
<p>What the program cannot easily test is how SO_REUSEADDR acts on sockets in TIME_WAIT state as it’s very tricky to force and keep a socket in that state. Fortunately most operating systems seems to simply behave like BSD here and most of the time programmers can simply ignore the existence of that state.<br>程序无法轻松测试的是，套接字如何 SO_REUSEADDR 作用于处于 TIME_WAIT 该状态的套接字，因为强制并保持套接字处于该状态非常棘手。幸运的是，大多数操作系统在这里似乎只是简单地表现得像 BSD，大多数时候程序员可以简单地忽略该状态的存在。</p>
<p>Here’s the code (I cannot include it here, answers have a size limit and the code would push this reply over the limit).<br><a target="_blank" rel="noopener" href="https://rextester.com/BUAFK86204">这是代码</a>（我不能在这里包含它，答案有大小限制，代码会把这个回复推到限制之外）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lixiang365.github.io">Lixiang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lixiang365.github.io/post/70e417a9.html">https://lixiang365.github.io/post/70e417a9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lixiang365.github.io" target="_blank">Lixiang's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/362d36fe.html" title="kbe脚本逻辑层带宽优化方向"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">kbe脚本逻辑层带宽优化方向</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/362d36fe.html" title="kbe脚本逻辑层带宽优化方向"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-20</div><div class="title">kbe脚本逻辑层带宽优化方向</div></div></a></div><div><a href="/post/cb10f09a.html" title="记一次iftop带宽显示和实际程序发送的字节不相等问题排查"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="title">记一次iftop带宽显示和实际程序发送的字节不相等问题排查</div></div></a></div><div><a href="/post/4a39f9e5.html" title="多人网络位置同步"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-13</div><div class="title">多人网络位置同步</div></div></a></div><div><a href="/post/f2e7e827.html" title="一次socket发送缓冲区溢出bug排查"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-20</div><div class="title">一次socket发送缓冲区溢出bug排查</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lixiang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lixiang365"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:frank338521@gmail.com" target="_blank" title="Email"><i class="fa-solid fa-envelope" style="color: ;"></i></a><a class="social-icon" href="https://lixiang365.github.io/rss2.xml" target="_blank" title="RSS"><i class="fa-solid fa-rss" style="color: ;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果图片不能访问，请尝试科学上网！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#BSD"><span class="toc-number">1.</span> <span class="toc-text">BSD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SO-REUSEADDR"><span class="toc-number">1.1.</span> <span class="toc-text">SO_REUSEADDR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SO-REUSEPORT"><span class="toc-number">1.2.</span> <span class="toc-text">SO_REUSEPORT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Connect-Returning-EADDRINUSE"><span class="toc-number">1.3.</span> <span class="toc-text">Connect() Returning EADDRINUSE?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multicast-Addresses-%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">1.4.</span> <span class="toc-text">Multicast Addresses 组播地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FreeBSD-OpenBSD-NetBSD"><span class="toc-number">2.</span> <span class="toc-text">FreeBSD&#x2F;OpenBSD&#x2F;NetBSD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#macOS-MacOS-X"><span class="toc-number">2.1.</span> <span class="toc-text">macOS (MacOS X)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iOS-watchOS-tvOS"><span class="toc-number">2.2.</span> <span class="toc-text">iOS &#x2F; watchOS &#x2F; tvOS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">Linux Linux操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-3-9"><span class="toc-number">3.1.</span> <span class="toc-text">Linux &lt; 3.9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-3-9-1"><span class="toc-number">3.2.</span> <span class="toc-text">Linux &gt;&#x3D; 3.9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android"><span class="toc-number">3.3.</span> <span class="toc-text">Android</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows"><span class="toc-number">4.</span> <span class="toc-text">Windows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Solaris"><span class="toc-number">5.</span> <span class="toc-text">Solaris</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Other-Systems-%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">Other Systems 其他系统</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/70e417a9.html" title="如何理解SO_REUSEADDR和SO_REUSEPORT？"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何理解SO_REUSEADDR和SO_REUSEPORT？"/></a><div class="content"><a class="title" href="/post/70e417a9.html" title="如何理解SO_REUSEADDR和SO_REUSEPORT？">如何理解SO_REUSEADDR和SO_REUSEPORT？</a><time datetime="2024-03-17T12:52:00.000Z" title="发表于 2024-03-17 20:52:00">2024-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/362d36fe.html" title="kbe脚本逻辑层带宽优化方向"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kbe脚本逻辑层带宽优化方向"/></a><div class="content"><a class="title" href="/post/362d36fe.html" title="kbe脚本逻辑层带宽优化方向">kbe脚本逻辑层带宽优化方向</a><time datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4faaacff.html" title="Python读取Excel配置表"><img src="https://s2.loli.net/2024/03/07/VoGYF6W35cTSw7P.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python读取Excel配置表"/></a><div class="content"><a class="title" href="/post/4faaacff.html" title="Python读取Excel配置表">Python读取Excel配置表</a><time datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f2e7e827.html" title="一次socket发送缓冲区溢出bug排查"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一次socket发送缓冲区溢出bug排查"/></a><div class="content"><a class="title" href="/post/f2e7e827.html" title="一次socket发送缓冲区溢出bug排查">一次socket发送缓冲区溢出bug排查</a><time datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/6e31043d.html" title="有限空间内毫米精度定位数据压缩算法"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="有限空间内毫米精度定位数据压缩算法"/></a><div class="content"><a class="title" href="/post/6e31043d.html" title="有限空间内毫米精度定位数据压缩算法">有限空间内毫米精度定位数据压缩算法</a><time datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Lixiang</div><div class="footer_custom_text"><p><a style="margin-inline:3px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=plastic&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:3px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=plastic&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:3px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=plastic&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>