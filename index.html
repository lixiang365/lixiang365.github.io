<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Lixiang's Blog</title><meta name="author" content="Lixiang"><meta name="copyright" content="Lixiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="Lixiang&#39;s Blog">
<meta property="og:url" content="https://lixiang365.github.io/index.html">
<meta property="og:site_name" content="Lixiang&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lixiang365.github.io/images/avatar.png">
<meta property="article:author" content="Lixiang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lixiang365.github.io/images/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lixiang365.github.io/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":1000,"position":"bottom","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Lixiang","link":"链接: ","source":"来源: Lixiang's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lixiang\'s Blog',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-09-29 10:37:50'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Lixiang's Blog" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="Lixiang's Blog" type="application/rss+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><nav id="nav"><span id="blog-info"><a href="/" title="Lixiang's Blog"><span class="site-name">Lixiang's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">Lixiang's Blog</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="mailto:frank338521@gmail.com" target="_blank" title="Email"><i class="fa-solid fa-envelope" style="color: ;"></i></a><a class="social-icon" href="https://lixiang365.github.io/rss2.xml" target="_blank" title="RSS"><i class="fa-solid fa-rss" style="color: ;"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/70e417a9.html" title="如何理解SO_REUSEADDR和SO_REUSEPORT？">如何理解SO_REUSEADDR和SO_REUSEPORT？</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-17T12:52:00.000Z" title="发表于 2024-03-17 20:52:00">2024-03-17</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-17T12:52:46.000Z" title="更新于 2024-03-17 20:52:46">2024-03-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><div class="content">注：（这篇文章原文是stack overflow的回答，觉得写的甚好，就转载保存下。原文连接）
Welcome to the wonderful world of portability… or rather the lack of it. Before we start analyzing these two options in detail and take a deeper look how different operating systems handle them, it should be noted that the BSD socket implementation is the mother of all socket implementations. Basically all other systems copied the BSD socket implementation at some point in time (or at least its interfaces) and then started evolving it on their own. ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/362d36fe.html" title="kbe脚本逻辑层带宽优化方向">kbe脚本逻辑层带宽优化方向</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-20T12:00:00.000Z" title="更新于 2024-01-20 20:00:00">2024-01-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B8%B8%E6%88%8F/">游戏</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/KBE%E5%BC%95%E6%93%8E/">KBE引擎</a></span></div><div class="content">kbe脚本逻辑层带宽优化方向分析消息带宽流量可以从两个方向来分析监测带宽流量
1. 消息协议必需字节说明msgid : 消息id 2个字节 uint16msglen : 消息长度 ，1、无参数的就没有消息长度，2、固定长度的消息也没有这个 3、可变长的消息长度默认是2个字节 uint16 消息过长，则会扩展 4个字节 uint32msgbody: 消息内容字节 （消息内容部分消息也会有固定字节占用，例如属性更新的entityid\aliasid,属性utype等等。不详细展开）
2. 程序内部记录发送的字节数1. 服务器内部有一个网络流量记录对象打开guiconsole工具
1234567891011121314151617181920212223242526272829303132333435class NetworkStats : public Singleton&lt;NetworkStats&gt;  &#123;  public:  enum S_OP&#123;  SEND,  RECV  &#125;; struct Stats &#123;  Stats()  &#12 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/4faaacff.html" title="Python读取Excel配置表">Python读取Excel配置表</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-20T12:00:00.000Z" title="更新于 2024-01-20 20:00:00">2024-01-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B8%B8%E6%88%8F/">游戏</a></span></div><div class="content">python 读取 Excel配置
读取Excel配置表 需要使用第三方库 openpyxl
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/f2e7e827.html" title="一次socket发送缓冲区溢出bug排查">一次socket发送缓冲区溢出bug排查</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-20T12:00:00.000Z" title="更新于 2024-01-20 20:00:00">2024-01-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B8%B8%E6%88%8F/">游戏</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/KBE%E5%BC%95%E6%93%8E/">KBE引擎</a></span></div><div class="content">

bug表现果冻大战中，突然客户端感觉很卡，然后大概2~3s后会恢复。偶现，近期才出现的（近期变动，修改了道具刷新策略）
排查过程1、首先查看了日志，发现确实在相关的时间点出现了，baseapp到客户端的socket发送缓冲区溢出，此时猜测有两种可能，一个是确实把发送缓冲区填满了。二是客户端网络延迟（这个是有可能出现的情况，并且也是偶尔出现的，符合特性），排查日志过程中，发现同时有cellapp到logger的缓冲区溢出，时间点比较接近。2、查看了Ubuntu系统默认的socket缓冲区大小，约200KB左右，另外因为bug是偶发的，并且存在时间非常短。如果出现了，很难在两三秒内查看系统状态，极难排查。3、因为有cellapp到logger的缓冲区溢出，这个时间点太巧了，如此接近，不得不令人心生怀疑。所以开始转变思路。先排查为什么logger缓冲区溢出（是发送还是接收的问题）4、因为最开始日志几十万行，无法一行一行看，都是搜索关键字查看的，所以错过了很多日志。这次我直接使用时间搜索，突然发现，在1s之内生成了1万条日志，问题明朗5、通过关键点打印，发现是道具逻辑的bug，魔鬼果冻的功 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/6e31043d.html" title="有限空间内毫米精度定位数据压缩算法">有限空间内毫米精度定位数据压缩算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-20T12:00:00.000Z" title="更新于 2024-01-20 20:00:00">2024-01-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B8%B8%E6%88%8F/">游戏</a></span></div><div class="content">原理在空间内的高精度定位使用float传输必然占用大量带宽。对于position，我们进行空间精度分割。首先按大的精度进行分割，然后在粗略的精度块内进行细致的精度，分割空间为每个高精度块，用每个块来标识最后的position在哪里。direction一样的，对角度进行不同精度的分割。
position假设需要1mm精度对空间进行以12mm为单位长度的三个坐标轴划分，使用3个字节进行存储x、y、z坐标（为什么使用12mm单位，因为我们要在一个小的空间内用一个字节标识所有高精度的空间块。因为最终我们的点取在空间块的中心，所以我们单元，所以单元长度是2*精度。高精度空间块数量必须&lt;&#x3D;256。取每个边6个比较好 12mm &#x3D; 6*2mm）。
对每个12mm边长的正方形空间内，以2mm为单位长度划分空间块，一共216个空间块，使用1个字节存储块标识。特殊情况：点如果在坐标原点的(precision * 6)范围内，就会丢失正负信息，所以使用-128这个特殊值，来标记这种特殊情况.
空间大小限制： 1mm 2 6 256&#x3D;边长3.072m的正方形。同理 精度越低 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/cb10f09a.html" title="记一次iftop带宽显示和实际程序发送的字节不相等问题排查">记一次iftop带宽显示和实际程序发送的字节不相等问题排查</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-18T12:00:00.000Z" title="发表于 2024-01-18 20:00:00">2024-01-18</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-18T12:00:00.000Z" title="更新于 2024-01-18 20:00:00">2024-01-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B8%B8%E6%88%8F/">游戏</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><div class="content">问题描述在做带宽优化时，把应用层socket发送的字节统计出来，然后在Linux使用iftop发现和统计的字节不相等，大概有2~3倍的差距。
分析问题
最开始觉得是TCP&#x2F;IP协议头占了多余的字节。然后开始在网上查其他人写的文档说，iftop是统计数据的，不涉及协议头。现在问题的关键就变成了验证iftop
后来换了环境，在windows系统下测了下，发现捕捉到的字节和socket发送的一致。Windows统计的是数据，不包括协议头。
后来怀疑是iftop工具问题，换了几个其他类型的工具，发现和iftop差不多。
网上找不到更多的iftop的相关文档，后来开始去github上找到iftop源码看，花费了几个小时终于找到了，iftop统计的是IP数据包，包括IP、TCP协议头、数据。破解了心中的疑惑。

有效负载有了正常的带宽情况、发送的字节数，可以计算出有效负载，发现有效负载很少，协议开销比较大。原因就是发送的数据包偏小，导致TCP\IP协议头占了大部分字节。TCP Socket有一个选项是TCP_NODELAY,如果是false的话，调用send，socket会立刻发送，当是 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/4a39f9e5.html" title="多人网络位置同步">多人网络位置同步</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-13T12:47:00.000Z" title="发表于 2024-01-13 20:47:00">2024-01-13</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-13T12:47:00.000Z" title="更新于 2024-01-13 20:47:00">2024-01-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B8%B8%E6%88%8F/">游戏</a></span></div><div class="content">多人游戏位置同步关于多人游戏的位置同步研究还是比较多的。这里我们主要描述下业内经典的同步方式

首先明确，服务器位置是权威的。
客户端操作和客户端自己的位置显示是分开的。
理想情况下，客户端显示位置应该和服务器相同。

正常情况是，客户端把操作发给服务器，比如向前走2s，然后服务器计算位置，在一定服务器帧率下(例如10HZ)把位置同步给所有客户端或者也可以把操作同步给所有客户端(包括自己)。然后客户端自己再修改显示自己的位置，客户端修改其他人的位置是通过收到服务器发过来的位置，通过插值修改。
同步出现的问题：自己客户端出现自己位置修改延迟，自己客户端其他人卡顿，卡视野，以下的方法都是为了解决这些问题。
预测正常情况下因为自己把操作同步给服务器后，服务器再把位置发给自己，这个过程考虑网络延迟需要时间。就造成客户端的操作和自己玩家的显示有延迟。
预测其实是指A客户端在通过摇杆，方向键修改位置时，把方向和时间同步给服务器后，然后立刻把位置更改应用的自己的显示上，解决操作和显示不顺畅的问题。因为网络延迟，实际上此时服务器还是上次同步的位置。等服务器收到了A客户端新的操作，然后服务器移动位置，然 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/63a698fd.html" title="Rust生命周期">Rust生命周期</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-17T02:52:00.000Z" title="发表于 2023-10-17 10:52:00">2023-10-17</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-17T02:52:46.000Z" title="更新于 2023-10-17 10:52:46">2023-10-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Rust%E5%9F%BA%E7%A1%80/">Rust基础</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Rust%E4%B8%93%E9%A2%98/">Rust专题</a></span></div><div class="content">根据rustlings里的例子，了解下lifetimes
lifetimes引用本身是一个指针，rust使用所有权系统来确保引用有效，但是编译器是相对保守的。在一些使用引用作为参数和返回值的函数，有时候代码没错但是却编译不过，因为编译器无法正确推理出引用的生命周期，无法保证安全，此时我们就需要使用生命周期标注告诉编译器引用的生命周期。从引用方向理解，生命周期就是要确保引用比所有者活的更久，因为引用依赖所有者。否则就出现了悬垂引用,rust要确保永远不会出现这种情况。
生命周期的特点
生命周期告诉编译器在给定情况下如何检查引用存活久到被认为有效。比如生命周期说 “确保参数 ‘a’ 和参数 ‘b’ 存活一样久使得返回值有效”。
它们仅在借用（即引用）时是必需的，因为复制或移动的参数在其作用域内，无法在外部引用。
生命周期意味可以检查例如函数的调用代码，以确保其参数有效。生命周期是由它们的调用者决定的.

lifetimes1123456789101112131415161718192021222324252627282930313233343536373839404142434445464 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/1654ffe7.html" title="Python热更思路">Python热更思路</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-05T09:19:00.000Z" title="发表于 2023-09-05 17:19:00">2023-09-05</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-05T09:19:53.000Z" title="更新于 2023-09-05 17:19:53">2023-09-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Python%E4%B8%93%E6%A0%8F/">Python专栏</a></span></div><div class="content">python 热更思路关于python类型的理解1、对于Python，最重要的一点理解是，万物皆对象。 Python 中的一切皆是对象，因此 Python 中的每个类本身也是一个对象，属于另外一个类的实例。Python中所有类都继承于这个object基类。
2、Object 类是所有 Python 对象的基类。在 Python 中，每个对象都是 Object 类的实例对象。因此，我们可以使用 Object 类中的方法和属性来操作和访问任何对象。
3、Class类是用于创建新类的类。当定义一个类的时候，这个类就是Class类的实例对象，但是这种说法不是很准确，准确来说，这个类的是Type类的实例对象，而不是Class类的实例对象。Class类和type类的关系是当每次使用Class创建新的类，python会自动调用type类的构造函数__new__()来创建一个新的类对象，并返回该对象的引用。然后，Python 解释器会进一步处理 class 语句中的代码，将其中定义的属性和方法等信息保存到该类对象的 dict 属性中。class 类本身并没有实例对象，可以将Class看做是用于创建类对 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/655fcddc.html" title="Rust 数据结构的内存布局">Rust 数据结构的内存布局</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-31T12:47:00.000Z" title="发表于 2023-08-31 20:47:00">2023-08-31</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-13T12:47:00.000Z" title="更新于 2023-09-13 20:47:00">2023-09-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Rust%E5%9F%BA%E7%A1%80/">Rust基础</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Rust%E4%B8%93%E9%A2%98/">Rust专题</a></span></div><div class="content">为什么要了解内存布局1、因为rust有自己的所有权规则，为了提高性能，有时候赋值数据并不是深拷贝。2、rust类型可以从size方面划分为两种，一种是在编译器知道size大小，另一种是动态size大小（DST），在某些时候这些概念可能难以理解。从底层了解内存布局后，会让我们对rust的一些优秀实现思想有所了解。3、学过C&#x2F;C++的同学应该对内存会更熟悉一些
存在栈中的类型只有在编译期确定大小的类型才会分配在栈上在栈上为函数分配的内存称为栈帧栈上分配内存只需要移动栈指针，不需要任何系统调用，非常快
i32 i32类型需要4个字节
存在堆上Box
Box类型是智能指针，在栈上只存了一个指针，64为系统就是8个字节，指针指向的数据存在在堆中，如果是一个I32，则在堆上需要4个字节，在rust中堆内存分配的定义在GlobalAlloc trait中。（注：当使用Box时，内存分配器并不一定使用系统调用，内存分配器会以块的形式请求内存，减少系统调用次数，同时内存释放时也不一定就返回给了系统，内存分配器会管理记录使用和未使用的内存。）

12345678910fn main()&#123 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lixiang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lixiang365"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:frank338521@gmail.com" target="_blank" title="Email"><i class="fa-solid fa-envelope" style="color: ;"></i></a><a class="social-icon" href="https://lixiang365.github.io/rss2.xml" target="_blank" title="RSS"><i class="fa-solid fa-rss" style="color: ;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果图片不能访问，请尝试科学上网！</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/70e417a9.html" title="如何理解SO_REUSEADDR和SO_REUSEPORT？">如何理解SO_REUSEADDR和SO_REUSEPORT？</a><time datetime="2024-03-17T12:52:00.000Z" title="发表于 2024-03-17 20:52:00">2024-03-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/362d36fe.html" title="kbe脚本逻辑层带宽优化方向">kbe脚本逻辑层带宽优化方向</a><time datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/4faaacff.html" title="Python读取Excel配置表">Python读取Excel配置表</a><time datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/f2e7e827.html" title="一次socket发送缓冲区溢出bug排查">一次socket发送缓冲区溢出bug排查</a><time datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/6e31043d.html" title="有限空间内毫米精度定位数据压缩算法">有限空间内毫米精度定位数据压缩算法</a><time datetime="2024-01-20T12:00:00.000Z" title="发表于 2024-01-20 20:00:00">2024-01-20</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/KBE%E5%BC%95%E6%93%8E/"><span class="card-category-list-name">KBE引擎</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Python%E4%B8%93%E6%A0%8F/"><span class="card-category-list-name">Python专栏</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Rust%E4%B8%93%E9%A2%98/"><span class="card-category-list-name">Rust专题</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Rust%E5%9F%BA%E7%A1%80/"><span class="card-category-list-name">Rust基础</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%B8%B8%E6%88%8F/"><span class="card-category-list-name">游戏</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="card-category-list-name">网络编程</span><span class="card-category-list-count">4</span></a></li>
            </ul></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">1</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">10</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2023-08-29T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">22.5k</div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-09-29T02:37:49.975Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Lixiang</div><div class="footer_custom_text"><p><a style="margin-inline:3px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=plastic&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:3px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=plastic&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:3px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=plastic&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: (str) => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: (subtitleType) => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        getScript('https://cdn.jsdelivr.net/npm/typed.js/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  }
}
</script><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(result =>{
      if (true) {
        const sub = []
        const content = result.data.content
        sub.unshift(content)
        typedJSFn.init(sub)
      } else {
        document.getElementById('subtitle').textContent = result.data.content
      }
    })
  })
}
typedJSFn.run(subtitleType)
</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>